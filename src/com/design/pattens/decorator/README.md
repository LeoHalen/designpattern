# 装饰者模式
####分类
    
####实现方式：
    
    a) 抽象的被装饰角色 （所有的角色都要直接或间接的实现本角色）
    
    b) 具体的被装饰角色，实现或继承a （被功能扩展的角色）
    
    c) 装饰角色，实现或继承a （本类有对a的引用，所有的具体装饰角色都需要继承这个角色）
    
    d) 多个具体修饰角色 ，继承c（对被装饰角色的功能扩展，可以任意搭配使用）
####应用场景：
#####1、优点：
    
    动态地给一个对象添加一些额外的职责。就增加功能来说，Decorator模式相比生成子类更为灵活。该模式以对客户端透明的方式扩展对象的功能。            
#####2、适用场景：
    对已有的业务逻辑进一步的封装，使其增加额外的功能
        （1）在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责。
        
        （2）处理那些可以撤消的职责。
        
        （3）当不能采用生成子类的方法进行扩充时。一种情况是，可能有大量独立的扩展，为支持每一种组合将产生大量的子类，使得子类数目
         呈爆炸性增长。另一种情况可能是因为类定义被隐藏，或类定义不能用于生成子类。
    以下都是单例模式的经典使用场景： 
        Java中的IO流就使用了装饰者模式，用户在使用的时候，可以任意组装，达到自己想要的效果。
#####3、实现场景
    我想吃三明治，首先我需要一根大大的香肠，我喜欢吃奶油，在香肠上面加一点奶油，再放一点蔬菜，最后再用两片面包夹一下，很丰盛的一顿午
    饭，营养又健康。